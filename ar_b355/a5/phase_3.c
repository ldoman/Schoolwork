#pragma config(Sensor, dgtl1,  turn_left,      sensorTouch)
#pragma config(Sensor, dgtl2,  turn_right,     sensorTouch)
#pragma config(Sensor, dgtl3,  shldr_bump,     sensorTouch)
#pragma config(Sensor, dgtl4,  s_quad,         sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  base_sonar,     sensorSONAR_inch)
#pragma config(Sensor, dgtl8,  e_quad,         sensorQuadEncoder)
#pragma config(Sensor, dgtl10, elbow_bump,     sensorTouch)
#pragma config(Sensor, dgtl11, shldr_move,     sensorTouch)
#pragma config(Sensor, dgtl12, shldr_move2,    sensorTouch)
#pragma config(Motor,  port2,           s_motor_2,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           s_motor_1,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           e_motor,       tmotorVex393, openLoop)
#pragma config(Motor,  port5,           claw_servo,    tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Constants
int S_SPEED = 127;
int E_SPEED = 127;
int NUM_SAMPLES = 10;
int SHLDR_MIN = 0;
int SHLDR_MAX = 100;
float ELBOW_MIN_Y_POS = 1.5;
float ELBOW_MIN_X_POS = -1.5;
float LEN_SHLDR = 12.5;
float LEN_ELBOW = 12.5;
float SHLDR_RATIO = 1.119;
float ELBOW_RATIO = 1.158;
int SAFE_ELBOW_MAX = 270;
int CAN_HEIGHT = 2;
int SHLDR_CAN_RELEASE_ANGLE = 40;
int ELBOW_CAN_RELEASE_ANGLE = 55;
int s_dists[] = {69, 53, 39, 28, 19};
int e_dists[] = {235, 215, 200, 184, 173};

// Variables
int left_bump;
int right_bump;
int e_safe_bump;
int s_safe_bump;
int shldr_angle;
int elbow_angle;
float can_dist;
int shldr_target_angle;
int elbow_target_angle;
int s_bump;
int s2_bump;

// dir: -1(down) or 1(up)
// time: ms
// speed: 0-127
void move_shoulder(int dir, int time, int speed)
{
    speed = (dir == -1) ? -speed : speed;
    motor[s_motor_1] = speed;
    motor[s_motor_2] = speed;
    wait1Msec(time);
    motor[s_motor_1] = 0;
    motor[s_motor_2] = 0;
}

// -1 moves up 1 moves down
void move_elbow(int dir, int time, int speed)
{
    speed = (dir == -1) ? -speed : speed;
    motor[e_motor] = speed;
    wait1Msec(time);
    motor[e_motor] = 0;
}

void reset_shoulder()
{
    SensorValue[s_quad] = 0;
    shldr_angle = SensorValue(s_quad);
    writeDebugStreamLine("shoulder dist: %d", shldr_angle);
}

void reset_elbow()
{
    SensorValue[e_quad] = 0;
    elbow_angle = SensorValue(e_quad);
    writeDebugStreamLine("ELBOW DIST: %d", elbow_angle);
}

float get_x_pos(int s_pos, int e_pos)
{
    float theta1 = s_pos * SHLDR_RATIO + 5.195;
    float theta2 = 360 - (e_pos * ELBOW_RATIO + .885); // 360 appears to give right x
    float alpha = PI - theta1 - theta2;
    float x = (LEN_SHLDR * cosDegrees(theta1) - LEN_ELBOW * cosDegrees(alpha));
    return x;
}

float get_y_pos(int s_pos, int e_pos)
{
    float theta1 = s_pos * SHLDR_RATIO + 5.195;
    float theta2 = 360 - (e_pos * ELBOW_RATIO + .885);
    float alpha = PI - theta1 - theta2;
    float y = (LEN_SHLDR * sinDegrees(theta1) + LEN_ELBOW * sinDegrees(alpha));
    return y;
}

float find_elbow_angle(int x, int y)
{
    float num = pow(x,2) + pow(y,2) - pow(LEN_SHLDR,2) - pow(LEN_ELBOW,2);
    float denom = 2 * LEN_SHLDR * LEN_ELBOW;
    return acos(degreesToRadians(num/denom));
}

float find_shldr_angle(int x, int y, float theta2)
{
    float ft = atan(degreesToRadians(y/x));
    float nom = LEN_SHLDR * sin(theta2);
    float denom = sqrt(pow(x,2) + pow(y,2));
    float st = asin(degreesToRadians(nom/denom));
    return ft - st;
}

void safe_check()
{
    // Get current sensor values
    s_safe_bump = SensorValue(shldr_bump);
    e_safe_bump = SensorValue(elbow_bump);
	shldr_angle = SensorValue(s_quad);
	elbow_angle = abs(SensorValue(e_quad));

    float claw_x_pos = get_x_pos(shldr_angle, elbow_angle);
	float claw_y_pos = get_y_pos(shldr_angle, elbow_angle);
	//writeDebugStreamLine("s,e: %d, %d", shldr_angle, elbow_angle);
	//writeDebugStreamLine("x,y: %.2f, %.2f", claw_x_pos, claw_y_pos);

	// Ensure safe parameters
    if(s_safe_bump == 1){
        reset_shoulder();
	    move_shoulder(1, 500, S_SPEED);
	}
	if(e_safe_bump == 1){
        reset_elbow();
	    move_elbow(1, 100, E_SPEED);
	}
	else if(shldr_angle < SHLDR_MIN) {
	    move_shoulder(1, 500, S_SPEED);
	}
	else if(shldr_angle >= SHLDR_MAX) {
	    move_shoulder(-1, 500, S_SPEED);
	}
	else if(claw_y_pos < ELBOW_MIN_Y_POS) {
	    writeDebugStreamLine("Claw y value below threshold");
	    if(elbow_angle < 90)
	    {
	        move_elbow(1, 50, E_SPEED);
	    }
	    else
	    {
	        move_elbow(-1, 50, E_SPEED);
	    }
	}
	else if(claw_x_pos < ELBOW_MIN_X_POS) {
        writeDebugStreamLine("Claw x value above threshold");
	    move_elbow(1, 50, E_SPEED);
	}
	else {
	    // Do nothing
	}
}

void move_shoulder_to(int pos)
{
    int dir = (shldr_angle - pos >= 0) ? -1 : 1;
    if(dir == 1)
    {
        while(shldr_angle <= pos)
	    {
	        safe_check();
	        move_shoulder(dir, 20, S_SPEED);
	    }
    }
    else
    {
        while(shldr_angle >= pos)
	    {
	        safe_check();
	        move_shoulder(dir, 20, S_SPEED);
	    }
    }
}

void close_claw()
{
     motor[claw_servo] = -127;
}

void open_claw()
{
     motor[claw_servo] = 127;
}

void move_elbow_to(int pos)
{
    int dir = (elbow_angle - pos >= 0) ? -1 : 1;
    int counter = 0;
    if(dir == 1)
    {
        while(elbow_angle <= pos)
	    {
	        if(counter > 400)
	        {
	            open_claw();
	            break;
	        }
	        counter++;
	        safe_check();
	        move_elbow(dir, 20, S_SPEED);
	        //wait1Msec(20);
	    }
    }
    else
    {
        while(elbow_angle >= pos)
	    {
	        if(counter > 400)
	        {
	            open_claw();
	            break;
	        }
	        counter++;
	        safe_check();
	        move_elbow(dir, 20, S_SPEED);
	        //wait1Msec(20);
	    }
    }
}

void force_reset_shoulder()
{
    s_safe_bump = SensorValue(shldr_bump);
    while(s_safe_bump == 0)
    {
        s_safe_bump = SensorValue(shldr_bump);
        writeDebugStreamLine("safe bump: %d", s_safe_bump);
        move_shoulder(-1, 100, S_SPEED);
    }

    reset_shoulder();
}

// Run this after force_reset_shldr
void force_reset_elbow()
{
    e_safe_bump = SensorValue(elbow_bump);
    while(e_safe_bump == 0)
    {
        e_safe_bump = SensorValue(elbow_bump);
        move_elbow(-1, 20, E_SPEED);
        wait1Msec(20);
    }

    reset_elbow();
}

void get_cans()
{
    for(int i = 0; i < 3; i++) // iter over num cans
    {
        open_claw();
        wait1Msec(500);
        writeDebugStreamLine("opened claw");
        move_elbow_to(20);
        move_shoulder_to(50);
        move_elbow_to(180);
        move_shoulder_to(75);
        writeDebugStreamLine("staged");
        writeDebugStreamLine("ACQUIRING TARGET");
        int scan = SensorValue(base_sonar);
        writeDebugStreamLine("scan: %d", scan);
        float perc = floor(((scan-14)/8.5)*5);
        writeDebugStreamLine("perc: %f", perc);
        int target_s = s_dists[(int)perc];
        int target_e = e_dists[(int)perc];
        writeDebugStreamLine("TARGET ACQUIRED");
        writeDebugStreamLine("target s: %d", target_s);
        writeDebugStreamLine("target e: %d", target_e);
        wait1Msec(1000);
        move_elbow_to(target_e);
        wait1Msec(4000);
        writeDebugStreamLine("moved elbow");
        move_shoulder_to(target_s);
        writeDebugStreamLine("moved shldr");
        close_claw();
        wait1Msec(500);
        writeDebugStreamLine("close claw");
        move_shoulder_to(shldr_angle+5);
        move_elbow_to(elbow_angle-60);
        writeDebugStreamLine("move to drop pos");
        move_shoulder_to(shldr_angle-5);
        move_elbow_to(elbow_angle-20);
        move_shoulder_to(SHLDR_CAN_RELEASE_ANGLE);
        move_elbow_to(ELBOW_CAN_RELEASE_ANGLE);
        open_claw();
        wait1Msec(500);
        force_reset_shoulder();
        force_reset_elbow();
    }
}

task main()
{
    wait1Msec(2000); // give stuff time to turn on

    // Reset joints
    force_reset_shoulder();
    force_reset_elbow();

    // Pick up cans
    get_cans();

    // Testing control loop
    while(true)
    {
        left_bump = SensorValue(turn_left);
		right_bump = SensorValue(turn_right);
		s_safe_bump = SensorValue(shldr_bump);
		shldr_angle = SensorValue(s_quad);
		s_bump = SensorValue(shldr_move);
		s2_bump = SensorValue(shldr_move2);

		//writeDebugStreamLine("shoulder angle: %d", shldr_angle * SHLDR_RATIO + 5.195);
		//writeDebugStreamLine("elbow dist: %d", elbow_angle * ELBOW_RATIO + .885);
        //writeDebugStreamLine("elbow dist: %d", elbow_angle);
		safe_check();

		if(left_bump == 1)
		{
		    move_elbow(-1, 20, E_SPEED);
		    //move_shoulder(-1, 20, S_SPEED);
		}
		else if(right_bump == 1)
		{
		    move_elbow(1, 20, E_SPEED);
		    //move_shoulder(1, 20, S_SPEED);
		}
		else if(s_bump == 1)
		{
		    move_shoulder(-1, 20, S_SPEED);
		}
		else if(s2_bump == 1)
		{
		    move_shoulder(1, 20, S_SPEED);
		}
		else
		{
		    motor[s_motor_1] = 0;
		    motor[s_motor_2] = 0;
		}
    }
}
