"""
B457 Assignment 4
"""

__author__ = "Luke Doman"

# Imports
from math import sin,cos
from matplotlib import *
import numpy as np
from PIL import Image
from pprint import pprint
from pylab import *
import random
import scipy.ndimage as ndi
from skimage import feature

def generate_cluster_dict(ar_im, pixels, clusters):
	"""
	Generates a dictionary where keys are tuples in form of (row, col) 
	and values are the cluster that pixel belongs to

	Args:
		ar_im (2d array): Array representation of image
		pixels (2d array): Array containing subarrays of each pixels RGB values
		clusters (np.array): Output of vq(kmeans)

	Returns:
		Generated dict
	"""
	size_y = len(ar_im)
	size_x = len(ar_im[0])
	cluster_dict = {}
	pixel_dict = {}

	i_0 = where(clusters==0)[0]
	i_1 = where(clusters==1)[0]
	i_2 = where(clusters==2)[0]

	c_list = [i_0, i_1, i_2]
	pixels = pixels.astype(np.int)

	for c in range(0, len(c_list)):
		for i in c_list[c]:
			pixel_dict[tuple(pixels[i])] = c

	for i in range (0,size_y):
		for j in range (0,size_x):
			try:
				c_id = pixel_dict[tuple(ar_im[i][j])]
			except KeyError:
				c_id = -1
			cluster_dict[(i,j)] = c_id

	return cluster_dict

def generate_filter(sigma, gradient, display = False):
	"""
	Generates and shows image kernel with specified parameters.

	Args:
		sigma (int): Sigma to be used for applying Gaussian filter
		gradient (2d array): Gradient to convolve Gaussian filter with
		display (bool): Whether or not to display new filter

	Returns:
		Generated filter
	"""
	# Create base filter - all black with center white pixel
	filter_base = np.zeros(shape=(51,51))
	center_pixel = int(len(filter_base)/2)
	filter_base[center_pixel][center_pixel] = 255

	gaus = filters.gaussian_filter(filter_base, (sigma,sigma))
	new_filter = convolve2d(gaus, gradient, mode='same')

	if display:
		imshow(new_filter, cmap='gray')
		show()

	return new_filter

def filter_diff(f1, f2, display = False):
	"""
	Generates a filter based on the differences between two filters.

	Args:
		f1 (filter -> 2d array): Filter 1
		f2 (filter -> 2d array): Filter 2
		display (bool): Whether or not to display new filter

	Returns:
		New filter (2d array)
	"""
	size_x = len(f1)
	size_y = len(f1[0])

	new_filter = np.zeros(shape=(size_x,size_y))

	for i in range(0, size_y):
		for j in range(0, size_x):
			new_filter[i][j] = 255 - abs(f1[i][j] - f2[i][j])

	if display:
		imshow(new_filter, cmap='gray')
		show()

	return new_filter

def get_vector(x, y, imgs):
	"""
	Get the 8-D vector of activation filters for the specified pixel of image

	Args:
		x (int): X position
		y (int): Y position
		imgs (Array of images): Activation images to generate vector from

	Returns:
		Vector of pixel values of each activation image
	"""
	v = []
	for im in imgs:
		v.append(im[x][y])

	return v

# Problem 1.1 - canny edge detection
def p1_1():
	im = Image.open('line_original.png').convert('L')
	ar_im = array(im)

	# Compute the Canny filter for two values of sigma
	edges1 = feature.canny(ar_im)
	edges2 = feature.canny(ar_im, sigma=3)

	# display results
	fig, (ax1, ax2, ax3) = subplots(nrows=1, ncols=3, figsize=(8, 3),
		                                sharex=True, sharey=True)

	ax1.imshow(ar_im, cmap=plt.cm.gray)
	ax1.axis('off')
	ax1.set_title('Default image', fontsize=20)

	ax2.imshow(edges1, cmap=plt.cm.gray)
	ax2.axis('off')
	ax2.set_title('Canny filter, $\sigma=1$', fontsize=20)

	ax3.imshow(edges2, cmap=plt.cm.gray)
	ax3.axis('off')
	ax3.set_title('Canny filter, $\sigma=3$', fontsize=20)

	fig.tight_layout()

	show()

def hough_transform(im, theta, d):
	"""	Performs Hough Tranform on passed image.

	Args:
		im (numpy array): Image to perform operation on
		theta (int): Max size of theta for bin
		d (int): Max size of d for bin

	Returns:
		Bin generated by transform
	"""
	size_y = len(im)
	size_x = len(im[0])
	h_bin = np.zeros(shape=(d, theta), dtype = int)
	d_values = []

	for y in range (0,size_y):
		for x in range (0,size_x):
			for t in range(0, theta):
				dist = x * cos(t) + y * sin(t)
				dist = abs(int(round(dist, 0)))
				#print dist
				h_bin[dist, t] += 1
				d_values.append(dist)

	#print d_values
	print max(d_values)
	return h_bin



# Problem 1.2
def p1_2():
	im = Image.open('line_original.png').convert('L')
	ar_im = feature.canny(array(im), sigma=3)
	h_bin = hough_transform(ar_im, 90, 700)

	imshow(h_bin, cmap='gray')
	show()

# Problem 1
def p1():
	class1 = 2.0 * randn(100,2)
	class2 = randn(100,2) + array([5,5])
	class3 = randn(50,2) + array([5,0])
	features = vstack((class1,class2,class3))
	centroids,variance = kmeans(features,3)
	code,distance = vq(features,centroids)

	figure()
	ndx = where(code==0)[0]
	plot(features[ndx,0],features[ndx,1],'*')
	ndx = where(code==1)[0]
	plot(features[ndx,0],features[ndx,1],'r.')
	ndx = where(code==2)[0]
	plot(features[ndx,0],features[ndx,1],'g.')
	plot(centroids[:,0],centroids[:,1],'go')
	axis('off')
	show()



# Problem 2
def p2(image, k = 4):
	im = array(Image.open(image).convert('RGB'))
	im = im.tolist()
	size_y = len(im)
	size_x = len(im[0])

	pixels = []
	for i in range (0,size_y):
		for j in range (0,size_x):
			pixels.append(im[i][j])

	features = array(pixels, dtype = float)
	centroids,variance = kmeans(features,k)
	code,distance = vq(features,centroids)

	figure()
	ndx = where(code==0)[0]
	plot(features[ndx,0],features[ndx,1],features[ndx,2],'*')
	ndx = where(code==1)[0]
	plot(features[ndx,0],features[ndx,1],features[ndx,2],'r.')
	ndx = where(code==2)[0]
	plot(features[ndx,0],features[ndx,1],features[ndx,2],'g.')
	plot(centroids[:,0],centroids[:,1],'go')
	axis('off')
	show()

	cluster_id = generate_cluster_dict(im, features, code)
	im2 = array(Image.open(image).convert('RGB'))
	im2 = im2.tolist()
	colors = map(matplotlib.colors.hex2color,random.sample(list(matplotlib.colors.cnames.values()),k))
	for row in range (0,size_y):
		for col in range (0,size_x):
			im2[row][col] = [x * 255 for x in colors[cluster_id[(row,col)]]]
	im = array(im2).astype(np.uint8)
	im = Image.fromarray(im,'RGB')

	imshow(im, cmap='gray')
	show()

# Problem 3
def p3(image, k = 4):
	im = Image.open(image).convert('L')
	act_imgs = a2_p2(im)
	im = array(Image.open(image).convert('RGB'))
	size_y = len(im)
	size_x = len(im[0])

	# Make im with 8d vectors for each pixel
	v_8d = []
	for i in range(0, size_y):
		for j in range(0, size_x):
			v = get_vector(i, j, act_imgs)
			v_8d.append(v)

	features = array(v_8d, dtype = float)
	centroids,variance = kmeans(features,k)
	code,distance = vq(features,centroids)

	shapes = ['*','r.','g.','b.','p.','o.']
	figure()
	for i in range(0, k):
		ndx = where(code==i)[0]
		plot(features[ndx,0],features[ndx,1],features[ndx,2],shapes[i])
	plot(centroids[:,0],centroids[:,1],'go')
	axis('off')
	show()

if __name__ == '__main__':
	#im = Image.open('zebra.jpg').convert('L')
	#p1_1()
	p1_2()

